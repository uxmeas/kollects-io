"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[990],{1252:function(e,t,r){let n;r.d(t,{F7:function(){return tP},IO:function(){return X},LH:function(){return tT},LQ:function(){return G},OK:function(){return e7},OL:function(){return eM},Z_:function(){return tx},b0:function(){return K},eQ:function(){return eO},gJ:function(){return eI},jK:function(){return tC},ts:function(){return tE},vc:function(){return g.vc},yz:function(){return eZ}});var a,o,i,s,c,d=r(5896),l=r(422),u=r(4086),f=r(5151),p=r.n(f),y=r(5144),g=r(8364),m=r(6667),h=r(2423),v=r(4832),w=r(3322),k=r(8401),b=r(3127),E=r(2207);r(614);var C=r(3553);let S="1.21.0",P=e=>t=>typeof t===e,R=e=>null!=e,A=P("object"),N=P("string"),T=P("function"),I=P("number");function _(e){return T(e)?e(d.R9,l):[]}async function O(e,t,r){(0,u.k)(R(r),`${t}(opts) -- opts is required`),(0,u.k)(A(r),`${t}(opts) -- opts must be an object`),(0,u.k)(!(r.cadence&&r.template),`${t}({ template, cadence }) -- cannot pass both cadence and template`),(0,u.k)(R(r.cadence||r?.template),`${t}({ cadence }) -- cadence is required`),(0,u.k)(N(r.cadence)||r?.template,`${t}({ cadence }) -- cadence must be a string`),(0,u.k)(await e.config.get("accessNode.api"),`${t}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)}async function U(e,t){return O(e,"mutate",t)}async function L(e,t){return O(e,"query",t)}async function D(e){let t,{url:r}=e;(0,u.k)(void 0!==r,"retrieve({ url }) -- url must be defined");try{t=await p()(r)}catch(e){throw Error("httpDocumentResolver Error: Failed to retrieve document.")}return t.ok?await t.json():null}let x=new Map([["http",D],["https",D]]);async function F(e,t){let{url:r}=t;(0,u.k)(void 0!==r,"retrieve({ url }) -- url must be defined"),(0,u.k)("string"==typeof r,"retrieve({ url }) -- url must be a string");let n=await e.config.where(/^document\.resolver\./);Object.keys(n).map(e=>{let t=n[e],r=e.replace(/^document\.resolver\./,"");x.set(r,t)});let a=/^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(r);(0,u.k)(a,"Failed to parse URL");let o=a[1];(0,u.k)(a,"Failed to parse URL protocol");let i=x.get(o);return(0,u.k)(i,`No resolver found for protcol=${o}`),await i({url:r})}async function $(e){let{network:t,template:r}=e;return(0,u.k)("1.0.0"===r.f_version,"deriveCadenceByNetwork100({ template }) -- template must be version 1.0.0"),Object.keys(r?.data?.dependencies).map(e=>{let n=Object.values(r?.data?.dependencies?.[e]);(0,u.k)(void 0!==n,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`),(0,u.k)(n.length>0,`deriveCadenceByNetwork100 -- Could not find contracts for dependency placeholder: ${e}`);let a=n[0],o=a?.[t];return(0,u.k)(o,`deriveCadenceByNetwork100 -- Could not find ${t} network information for dependency: ${e}`),[e,o?.address]}).reduce((e,t)=>{let[r,n]=t,a=RegExp("(\\b"+r+"\\b)","g");return e.replace(a,n)},r.data.cadence)}async function j(e){let{network:t,template:r}=e;(0,u.k)("1.1.0"===r.f_version,"deriveCadenceByNetwork110({ template }) -- template must be version 1.1.0");let n={};return r?.data?.dependencies.forEach(e=>{e.contracts.forEach(e=>{let r=e.contract;e.networks.forEach(e=>{e.network===t&&(n[r]=e.address)}),u.k(void 0!==n[r],`deriveCadenceByNetwork110 -- Could not find contracts Network Address: ${t} ${r}`)})}),(0,u.k)(Object.keys(n).length===r?.data?.dependencies.length,`deriveCadenceByNetwork110 -- Could not find contracts for import dependencies: ${n}`),(0,u.k)(Object.keys(n).length===Object.values(n).length,`deriveCadenceByNetwork110 -- Could not find all addresses for network ${t} dependencies:  ${n}`),(0,u.k)(!!r?.data?.cadence?.body,`no cadence found -- Could not replace import dependencies: ${n}`),function(e){let{cadence:t,networkDependencies:r}=e;return Object.keys(r).reduce((e,t)=>{let n=r[t],a=RegExp(`import "\\b${t}\\b"`,"g");return e.replace(a,`import ${t} from ${n}`)},t)}({cadence:r?.data?.cadence?.body,networkDependencies:n})}async function z(e){let{network:t,template:r}=e;switch((0,u.k)(void 0!=t,"deriveCadenceByNetwork({ network }) -- network must be defined"),(0,u.k)("string"==typeof t,"deriveCadenceByNetwork({ network }) -- network must be a string"),(0,u.k)(void 0!=r,"deriveCadenceByNetwork({ template }) -- template must be defined"),(0,u.k)("object"==typeof r,"deriveCadenceByNetwork({ template }) -- template must be an object"),(0,u.k)("InteractionTemplate"===r.f_type,"deriveCadenceByNetwork({ template }) -- template must be an InteractionTemplate"),r.f_version){case"1.1.0":return await j({network:t,template:r});case"1.0.0":return await $({network:t,template:r});default:throw Error("deriveCadenceByNetwork Error: Unsupported template version")}}async function q(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return(await e.sdk.send([(0,d.Nj)()],t).then(e.sdk.decode)).chainId}function M(){return{config:(0,g.vc)(),sdk:{send:d.Jd,decode:d.Jx,subscribe:d.Ld,subscribeRaw:d.ju,account:d.JT,block:d.Ge,resolve:d.DB}}}let H={},B=!1;function W(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=await e.config.get("flow.network"),n=await e.config.get("env");n&&!B&&(y.cM.deprecate({pkg:"FCL",subject:'Using the "env" configuration key for specifying the flow network',message:"Configuring to specify flow network is no longer required",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"}),B=!0);let a=t.node||await e.config.get("accessNode.api");if(!a){if(r)return r;if(n)return n;throw Error('Either the "accessNode.api" config key or opts.node must be set')}if(H[a])try{return await H[a]}catch{}H[a]||(H[a]=q(e,t).catch(e=>{throw H[a]=null,e}));try{return await H[a]}catch(e){if(r)return r;if(n)return n;throw Error(`Error getting chainId from access node - are you using the correct access node endpoint.  If running locally, is your emulator up-to-date? ${e.message}`)}}}let G=W(M());async function J(e,t){N(t?.template)&&(t.template=await F(e,{url:t?.template}));let r=t.cadence||await z({template:t.template,network:await W(e)(t)});return t.cadence=r,t}function V(e){return async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return await L(e,t),t=await J(e,t),e.sdk.send([d._v(t.cadence),d.WC(_(t.args||[])),d.Iw(t.isSealed??!1),t.limit&&"number"==typeof t.limit&&d.b9(t.limit)])})(t).then(e.sdk.decode)}}M();let X=V(M()),K={"HTTP/RPC":"HTTP/RPC","HTTP/POST":"HTTP/POST","IFRAME/RPC":"IFRAME/RPC","POP/RPC":"POP/RPC","TAB/RPC":"TAB/RPC","EXT/RPC":"EXT/RPC","DEEPLINK/RPC":"DEEPLINK/RPC"},Y={f_type:"Service",f_vsn:"1.0.0"},Z={f_type:"Identity",f_vsn:"1.0.0"},Q={f_type:"USER",f_vsn:"1.0.0"},ee={f_type:"PollingResponse",f_vsn:"1.0.0"},et={f_type:"CompositeSignature",f_vsn:"1.0.0"},er=(e,t)=>h.lW.from(e.padStart(2*t,"0"),"hex");d.Oq;let en=e=>{if(e.appIdentifier){let{appIdentifier:t,address:r,nonce:n,signatures:a}=e;return(0,u.k)(N(t),"verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"),(0,u.k)(N(r)&&16===(0,m.CH)(r).length,"verifyAccountProof({ address }) -- address must be a valid address"),(0,u.k)(/^[0-9a-f]+$/i.test(n),"nonce must be a hex string"),(0,u.k)(Array.isArray(a)&&a.every((e,t,r)=>"CompositeSignature"===e.f_type),"Must include an Array of CompositeSignatures to verify"),(0,u.k)(a.map(e=>e.addr).every((e,t,r)=>e===r[0]),"User signatures to be verified must be from a single account address"),!0}{let{message:t,address:r,compSigs:n}=e;return(0,u.k)(/^[0-9a-f]+$/i.test(t),"Signed message must be a hex string"),(0,u.k)(N(r)&&16===(0,m.CH)(r).length,"verifyUserSignatures({ address }) -- address must be a valid address"),(0,u.k)(Array.isArray(n)&&n.every((e,t,r)=>"CompositeSignature"===e.f_type),"Must include an Array of CompositeSignatures to verify"),(0,u.k)(n.map(e=>e.addr).every((e,t,r)=>e===r[0]),"User signatures to be verified must be from a single account address"),!0}},ea=async(e,t,r)=>{let n="ACCOUNT_PROOF"===t?"verifyAccountProofSignatures":"verifyUserSignatures",a=await W(e)(r),o=r.fclCryptoContract||({testnet:"0x74daa6f9c7ef24b1",mainnet:"0xb4b82a1c9d21d284",previewnet:"0x40b5b8b2ce81ea4a"})[a];return(0,u.k)(o,`${n}({ fclCryptoContract }) -- FCLCrypto contract address is unknown for network: ${a}. Please manually specify the FCLCrypto contract address.`),`
      import FCLCrypto from ${o}

      access(all) fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${n}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `};M();let eo=(a=M(),async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=(0,m.dq)(t[0].addr);en({message:e,address:n,compSigs:t});let o=[],i=[];for(let e of t)o.push(e.signature),i.push(e.keyId.toString());return V(a)({cadence:await ea(a,"USER_SIGNATURE",r),args:(t,r)=>[t(n,r.Address),t(e,r.String),t(i,r.Array(r.Int)),t(o,r.Array(r.String))]})});y.cM.deprecate({pkg:"FCL",subject:"fcl.verifyUserSignatures()",message:"Please use fcl.AppUtils.verifyUserSignatures()",callback:function(e,t){return eo(e,t)}}),M();let ei=/\[Error Code: (\d+)\]/;class es extends Error{constructor(e,t){super(e),this.code=t,this.type=v.fm[t]}static fromErrorMessage(e){let t=e.match(ei);return new es(e,(t?parseInt(t[1],10):void 0)||v.fm.UNKNOWN_ERROR)}}async function ec(e,t){return Object.fromEntries(Object.entries(await e.config.where(t)).map(e=>{let[r,n]=e;return[r.replace(t,""),n]}))}let ed=e=>e.status>=4,el=e=>e.status>=3,eu=e=>e.status>=2,ef=(e,t)=>{if(e===t)return!0;if("object"!=typeof e||"object"!=typeof t||Object.keys(e).length!==Object.keys(t).length)return!1;for(let r in e)if(!ef(e[r],t[r]))return!1;return!0},ep=(e,t)=>!ef(e,t),ey=e=>{if("object"==typeof e&&(e=e.transactionId),null==e)throw Error("transactionId required");return e},eg=/^[0-9a-fA-F]{64}$/,em="POLL",eh="TIMEOUT",ev=async e=>(0,d.Jd)([(0,d.Lv)(e)]).then(d.Jx),ew=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{[w.qg]:async t=>{setTimeout(()=>t.sendSelf(eh),e.txNotFoundTimeout),t.sendSelf(em)},[w.kD]:(e,t)=>{e.subscribe(t.from),e.send(t.from,w.SH,e.all())},[w.By]:(e,t)=>{e.unsubscribe(t.from)},[w.kT]:async(e,t)=>{t.reply(e.all())},[eh]:async t=>{0===Object.keys(t.all()).length&&t.fatalError(Error(`TX status polling failed: no transaction was found within timeout interval (${e.txNotFoundTimeout}ms)`))},[em]:async t=>{let r;let n=()=>setTimeout(()=>t.sendSelf(em),e.pollRate),a=t.all();try{r=await ev(t.self())}catch(a){let e=a instanceof k.NL&&404===a.statusCode,r=a.code===b.grpc.Code.NotFound;if(e||r)return n();return t.fatalError(a)}ed(r)||n(),ep(a,r)&&t.broadcast(w.SH,r),t.merge(r)}}},ek=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>(0,w.Cs)(ew(e),ey(t))};function eb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{txNotFoundTimeout:12500,pollRate:1e3};if(!eg.test(ey(e)))throw Error("Invalid transactionId");function r(r){return(0,w.qP)(ey(e),ek(t),r)}function n(e){return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=t.suppress||!1;return new Promise((t,a)=>{let o=r((r,i)=>{if((i||r.statusCode)&&!n){null!=i?(a(i),o()):1===r.statusCode&&(a(es.fromErrorMessage(r.errorMessage)),o());return}e(r)&&(t(r),o())})})}}return{snapshot:function(){return(0,w.L6)(e,ek(t))},subscribe:r,onceFinalized:n(eu),onceExecuted:n(el),onceSealed:n(ed)}}eb.isUnknown=e=>e.status>=0,eb.isPending=e=>e.status>=1,eb.isFinalized=eu,eb.isExecuted=el,eb.isSealed=ed,eb.isExpired=e=>5===e.status,M();M();let eE=()=>{throw Error("Platform specific Core Strategies are not initialized")},eC={[K["EXT/RPC"]]:eE,[K["HTTP/POST"]]:eE,[K["IFRAME/RPC"]]:eE,[K["POP/RPC"]]:eE,[K["TAB/RPC"]]:eE,[K["EXT/RPC"]]:eE},eS=["ServicePlugin"],eP=["discovery-service"],eR=e=>{let{services:t=[],serviceStrategy:r}=e;for(let e of((0,u.k)(Array.isArray(t),"Services must be an array"),t))(0,u.k)(R(e.f_type)&&"Service"===e.f_type,"Service is required"),(0,u.k)(R(e.type)&&"authn"===e.type,`Service must be type authn. Received ${e.type}`),(0,u.k)(e.method in K||r.method===e.method,`Service method ${e.method} is not supported`);return(0,u.k)(R(r),"Service strategy is required"),(0,u.k)(R(r.method)&&N(r.method),"Service strategy method is required"),(0,u.k)(R(r.exec)&&T(r.exec),"Service strategy exec function is required"),{discoveryServices:t,serviceStrategy:r}},eA=e=>{let{coreStrategies:t}=e,r=new Set,n=new Map(Object.entries(t)),a=e=>r=new Set([...e]);return Object.freeze({add:e=>{if((0,u.k)(eP.includes(e.type),`Service Plugin type ${e.type} is not supported`),"discovery-service"===e.type){let{discoveryServices:t,serviceStrategy:r}=eR(e);a(t),n.has(r.method)?(0,y.cM)({title:"Add Service Plugin",message:`Service strategy for ${r.method} already exists`,level:y.zq.warn}):n.set(r.method,r.exec)}},getServices:()=>[...r],getStrategy:e=>n.get(e),getStrategies:()=>[...n.keys()]})},eN=e=>{let t;for(let r of((0,u.k)(!!e,"No plugins supplied"),t=Array.isArray(e)?[...e]:[e]))(0,u.k)(R(r.name),"Plugin name is required"),(0,u.k)(R(r.f_type),"Plugin f_type is required"),(0,u.k)(eS.includes(r.f_type),`Plugin type ${r.f_type} is not supported`);return t},eT=()=>void 0!==n,eI=e=>{let{coreStrategies:t}=e;if(eT())return n;let r=eA({coreStrategies:t});return n=r,r},e_=()=>eT()?n:(console.warn("Registry is not initalized, it will be initialized with stub core strategies"),eI({coreStrategies:eC})),eO=(()=>{let e=new Map;return Object.freeze({add:t=>{for(let r of eN(t))e.set(r.name,r),"ServicePlugin"===r.f_type&&n.add(r)},getPlugins:()=>e})})(),eU=async()=>[...window?.fcl_extensions||[],...e_().getServices()];async function eL(e,t){let r=await e.config.get("discovery.authn.include",[]),n=await e.config.get("discovery.authn.exclude",[]),a=await e.config.get("discovery.features.suggested",[]),o=await e.config.first(["discovery.wallet.method","discovery.wallet.method.default"],void 0),i=t?.method?t.method:o,s=t?.endpoint??await e.config.first(["discovery.wallet","challenge.handshake"],void 0);return(0,u.k)(s,`
    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.
    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
    `),{...t,type:"authn",endpoint:s,method:i,discoveryAuthnInclude:r,discoveryAuthnExclude:n,discoveryFeaturesSuggested:a}}let eD=globalThis.URL,ex=class extends eD{constructor(e,t){for(var r=arguments.length,n=Array(r>2?r-2:0),a=2;a<r;a++)n[a-2]=arguments[a];super(e,t,...n);return}};async function eF(e){let{context:t,types:r}=e,n=await t.config.get("discovery.authn.endpoint");(0,u.k)(!!n,'"discovery.authn.endpoint" in config must be defined.');let a=await t.config.get("discovery.authn.include",[]),o=await t.config.get("discovery.authn.exclude",[]);return fetch(new ex(n),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({type:r,fclVersion:S,include:a,exclude:o,features:{suggested:await t.config.get("discovery.features.suggested",[])},clientServices:await eU(),supportedStrategies:e_().getStrategies(),userAgent:window?.navigator?.userAgent,network:await G()})}).then(e=>e.json())}let e$={AUTHN:"authn",SNAPSHOT:"SNAPSHOT",UPDATED:"UPDATED",UPDATE_RESULTS:"UPDATE_RESULTS"},ej=(e,t)=>{e&&console.warn(`
      %cFCL Warning
      ============================
      ${t}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `,"font-weight:bold;font-family:monospace;")},ez=async e=>{try{let t=await eF({context:e,types:[e$.AUTHN]});(0,w.lW)(e$.AUTHN,e$.UPDATE_RESULTS,{results:t})}catch(e){(0,y.cM)({title:`${e.name} Error fetching Discovery API services.`,message:e.message,level:y.zq.error})}},eq=e=>(0,w.Cs)({[w.qg]:async t=>{ej("undefined"==typeof window,'"fcl.discovery" is only available in the browser.'),"complete"===document.readyState?ez(e):window.addEventListener("load",()=>{ez(e)})},[e$.UPDATE_RESULTS]:(e,t,r)=>{e.merge(r),e.broadcast(e$.UPDATED,{...e.all()})},[w.kD]:(e,t)=>{e.subscribe(t.from),e.send(t.from,e$.UPDATED,{...e.all()})},[w.By]:(e,t)=>e.unsubscribe(t.from),[e$.SNAPSHOT]:async(e,t)=>t.reply({...e.all()})},e$.AUTHN),eM={authn:(o=M(),{subscribe:e=>(0,w.qP)(e$.AUTHN,()=>eq(o),e),snapshot:()=>(0,w.L6)(e$.AUTHN,()=>eq(o)),update:()=>{"complete"===document.readyState&&ez(o)}})};function eH(e){let t=new E.Aj(256);return t.update(h.lW.from(e,"utf8")),t.digest("hex")}function eB(e){let{contractName:t,address:r}=e;return{contractName:t,address:r,contract:""}}function eW(e){let t=[];for(let r of e.match(/import ((\w|,| )+)* from 0x\w+/g)||[]){let e=/import ((\w+|, |)*) from (0x\w+)/g.exec(r),n=/((?:\w+)+),?/g;for(let r of e?.[1].match(n)||[])t.push(eB({address:e?.[3],contractName:r.replace(/,/g,"")}))}return t}function eG(e){return async function(t){let{address:r,contractName:n}=t,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,d.kG)(void 0!=r,"generateDependencyPin({ address }) -- address must be defined"),(0,d.kG)(void 0!=n,"generateDependencyPin({ contractName }) -- contractName must be defined"),(0,d.kG)("string"==typeof r,"generateDependencyPin({ address }) -- address must be a string"),(0,d.kG)("string"==typeof n,"generateDependencyPin({ contractName }) -- contractName must be a string");let o=[eB({contractName:n,address:r})];for(let t of o){let r=await e.sdk.send([(0,d.D0)(await e.config.get(t.address,t.address))],a).then(e.sdk.decode);if(t.contract=r.contracts?.[t.contractName],!t.contract)throw console.error("Did not find expected contract",t,r),Error("Did not find expected contract");let n=eW(t.contract);o.push(...n)}let i=o.map(e=>eH(e.contract));return eH((await Promise.all(i)).join(""))}}let eJ=eG(M());async function eV(e,t,r){let n=[];for(let a of r){let r=[eH(a.network)],{address:o,dependency_pin_block_height:i}=a;if(a.dependency_pin){let n=await eG(e)({address:o,contractName:t,blockHeight:i});r.push(eH(n))}n.push(r)}return n}async function eX(e,t){let r=[];for(let n=0;n<t.length;n++){let a=t[n],o=[];for(let t=0;t<a?.contracts.length;t++){let r=a?.contracts[t],n=r?.contract;o.push(eH(n));let i=await eV(e,n,r?.networks);o.push(i)}r.push(o)}return r}i=M();let eK=(s=M(),async function(e){let{address:t,contractName:r}=e,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,d.kG)(void 0!=t,"generateDependencyPin({ address }) -- address must be defined"),(0,d.kG)(void 0!=r,"generateDependencyPin({ contractName }) -- contractName must be defined"),(0,d.kG)("string"==typeof t,"generateDependencyPin({ address }) -- address must be a string"),(0,d.kG)("string"==typeof r,"generateDependencyPin({ contractName }) -- contractName must be a string");let a=[eB({contractName:r,address:t})];for(let e of a){let t=await s.sdk.send([(0,d.D0)(await s.config.get(e.address,e.address))],n).then(s.sdk.decode);if(e.contract=t.contracts?.[e.contractName],!e.contract)throw console.error("Did not find expected contract",e,t),Error("Did not find expected contract");let r=eW(e.contract);a.push(...r)}let o=a.map(e=>eH(e.contract)).join("");return eH(o)}),eY=e=>async function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};try{await U(e,t),t=await J(e,t);let r=await e.config.get("fcl.authz",e.currentUser.authorization);return e.sdk.send([d.PS(t.cadence),d.WC(_(t.args||[])),t.limit&&I(t.limit)&&d.b9(t.limit),d.iB(t.proposer||t.authz||r),d.$C(t.payer||t.authz||r),d.KX(t.authorizations||[t.authz||r])]).then(e.sdk.decode)}catch(e){throw e}},eZ=e=>eY({...M(),currentUser:e});function eQ(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...et,addr:(0,m.CH)(e.addr||e.address),signature:e.signature||e.sig,keyId:e.keyId}}function e0(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{old:e,...Y,type:"frame",endpoint:e.endpoint,params:e.params||{},data:e.data||{}}}function e1(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:"back-channel-rpc",endpoint:e.endpoint,method:e.method,params:e.params||{},data:e.data||{}}}function e2(e){return null==e?null:(null==e.method&&(e={...e,type:"local-view",method:"VIEW/IFRAME"}),e.f_vsn)?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type||"local-view",method:e.method,endpoint:e.endpoint,data:e.data||{},params:e.params||{}}}let e4={"back-channel-rpc":e1,"pre-authz":function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Z,address:(0,m.dq)(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authz:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.endpoint,method:e.method,identity:{...Z,address:(0,m.dq)(e.addr),keyId:e.keyId},params:e.params,data:e.data}},authn:function(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...Y,type:e.type,uid:e.id,endpoint:e.authn,id:e.pid,provider:{address:(0,m.dq)(e.addr),name:e.name,icon:e.icon}}},frame:e0,"open-id":function(e){return null==e?null:"1.0.0"===e.f_vsn?e:null},"user-signature":function(e){if(null==e)return null;if(!e.f_vsn)throw Error("Invalid user-signature service");return"1.0.0"===e.f_vsn?e:null},"local-view":e2,"account-proof":function(e){if(null==e)return null;if(!e.f_vsn)throw Error("FCL Normalizer Error: Invalid account-proof service");return"1.0.0"===e.f_vsn?e:null},"authn-refresh":function(e){if(null==e)return null;if(!e.f_vsn)throw Error("Invalid authn-refresh service");return"1.0.0"===e.f_vsn?e:null}};async function e9(e,t){if(null==e||null==t)return[];let r=new ex(e);r.searchParams.append("code",t);let n=await fetch(r,{method:"GET",headers:{"Content-Type":"application/json"}}).then(e=>e.json());if(Array.isArray(n))return n;let a=[];if(Array.isArray(n.authorizations))for(let e of n.authorizations)a.push({type:"authz",keyId:n.keyId,...e});return null!=n.provider&&a.push({type:"authn",id:"wallet-provider#authn",...n.provider}),a}function e6(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0;return e.reduce((e,r)=>r.type===t&&(!e||C.q(r.f_vsn,e.f_vsn)>0)?r:e,null)}async function e5(e){(t=e).addr=t.addr?(0,m.dq)(t.addr):null,t.paddr=t.paddr?(0,m.dq)(t.paddr):null;var t,r=(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return[...e,...t]})((e=t).services||[],await e9(e.hks,e.code)).map(e=>(function(e,t){try{return e4[e.type](e,t)}catch(t){return console.error(`Unrecognized FCL Service Type [${e.type}]`,e,t),e}})(e,void 0)).filter(Boolean);let n=e6(r,"authn");return{...Q,addr:(0,m.dq)(e.addr),cid:h.cv([n.provider?.address||n.provider?.name||"UNSPECIFIED",n.id]).toString("hex"),loggedIn:!0,services:r,expiresAt:e.expires}}let e3="undefined"==typeof window,e8=globalThis.AbortController||r(8741),e7=async e=>{let{service:t,body:r,config:n,abortSignal:a,customRpc:o,user:i,opts:s}=e;return e_().getStrategy(t.method)({service:t,body:r,config:n,abortSignal:a,customRpc:o,opts:s,user:i})};async function te(e,t){let{service:r,msg:n={},config:a={},opts:o={},platform:i,abortSignal:s=new e8().signal,execStrategy:c,user:d}=t;!e3&&(e_().getStrategies().includes("WC/RPC")||y.cM({title:"FCL WalletConnect Service Plugin",level:y.zq.error,message:"All dApps are expected to register for a WalletConnect projectId & add this to their FCL configuration.  If you do not do so, users will be unable to use certain wallets to interact with your dApp.  See https://developers.flow.com/tools/clients/fcl-js/configure-fcl for more information."})),n.data=r.data;let l={services:await ec(e,/^service\./),app:await ec(e,/^app\.detail\./),client:{...a.client,platform:i,fclVersion:S,fclLibrary:"https://github.com/onflow/fcl-js",hostname:window?.location?.hostname??null,network:await W(e)(o)}};try{let t=await (c||e7)({service:r,body:n,config:l,opts:o,user:d,abortSignal:s});if("REDIRECT"===t.status)return(0,u.k)(r.type===t.data.type,"Cannot shift recursive service type in execService"),await te(e,{service:t.data,msg:n,config:l,opts:o,abortSignal:s,platform:i,user:d});return t}catch(e){throw(0,y.cM)({title:`Error on execService ${r?.type}`,message:e,level:y.zq.error}),e}}let tt=e=>"function"==typeof e,tr="CURRENT_USER",tn="CURRENT_USER/UPDATED",ta="SNAPSHOT",to="SET_CURRENT_USER",ti="DEL_CURRENT_USER",ts=`{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`,tc=async e=>{let t=JSON.parse(ts),r=await e.get(tr);return null!=r&&t.f_vsn!==r.f_vsn?(e.removeItem(tr),t):r||t},td=e=>{let t=async()=>e.getStorageProvider?await e.getStorageProvider():await e.config.first(["fcl.storage","fcl.storage.default"],void 0);return{[w.qg]:async e=>{"undefined"==typeof window&&console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `,"font-weight:bold;font-family:monospace;"),e.merge(JSON.parse(ts));let r=await t();if(r.can){let t=await tc(r);(null==t.expiresAt||0===t.expiresAt||t.expiresAt>Date.now())&&e.merge(t)}},[w.kD]:(e,t)=>{e.subscribe(t.from),e.send(t.from,tn,{...e.all()})},[w.By]:(e,t)=>{e.unsubscribe(t.from)},[ta]:async(e,t)=>{t.reply({...e.all()})},[to]:async(e,r,n)=>{e.merge(n);let a=await t();a.can&&a.put(tr,e.all()),e.broadcast(tn,{...e.all()})},[ti]:async(e,r)=>{e.merge(JSON.parse(ts));let n=await t();n.can&&n.put(tr,e.all()),e.broadcast(tn,{...e.all()})}}},tl=e=>{(0,w.Cs)(td(e),e.actorName)};async function tu(e){let t=await e.config.get("fcl.accountProof.resolver");if(null==t)return;if(!tt(t)){(0,y.cM)({title:"Account Proof Data Resolver must be a function",message:`Check fcl.accountProof.resolver configuration.
                Expected: fcl.accountProof.resolver: async () => { ... }
                Received: fcl.accountProof.resolver: ${typeof t}
                `,level:y.zq.warn});return}let r={...await t()},n=window?.location?.origin;return r.appIdentifier?n&&(y.cM.deprecate({pkg:"FCL",subject:"appIdentifier in fcl.accountProof.resolver",message:"Manually set app identifiers in the account proof resolver function are now deprecated.  These are now automatically set to the application origin URL by FCL",transition:"https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-appIdentifier-field-in-account-proof-resolver"}),(0,u.k)("string"==typeof r.appIdentifier,"appIdentifier must be a string")):((0,u.k)(n,"The appIdentifier (origin) could not be inferred from the window.location.origin.  Please set the appIdentifier manually in the fcl.accountProof.resolver function."),r.appIdentifier=n),(0,u.k)(/^[0-9a-f]+$/i.test(r.nonce),"Nonce must be a hex string"),r}let tf=async e=>{let{discoveryAuthnInclude:t,discoveryAuthnExclude:r,discoveryFeaturesSuggested:n}=e;return{client:{discoveryAuthnInclude:t,discoveryAuthnExclude:r,discoveryFeaturesSuggested:n,clientServices:await eU(),supportedStrategies:e_().getStrategies()}}},tp=e=>async function(){let{service:t,redir:r=!1,forceReauth:n=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(t&&!t?.provider?.is_installed&&t?.provider?.requires_install){window.location.href=t?.provider?.install_link;return}return new Promise(async(a,o)=>{let i;tl(e);let s={redir:r},c=await th(e)(),d=e6(c.services,"authn-refresh");if(c.loggedIn&&!n){if(!d)return a(c);try{let t=await te(e,{service:d,msg:i,opts:s,platform:e.platform,user:c});(0,w.lW)(e.actorName,to,await e5(t))}catch(e){(0,y.cM)({title:`${e.name} Could not refresh wallet authentication.`,message:e.message,level:y.zq.error})}finally{return a(await th(e)())}}try{i=await tu(e)}catch(e){return(0,y.cM)({title:`${e.name} On Authentication: Could not resolve account proof data.`,message:e.message,level:y.zq.error}),o(e)}try{let r=await eL(e,t),n=await te(e,{service:r,msg:i,config:await tf(r),opts:s,platform:e.platform,execStrategy:e.discovery?.execStrategy,user:c});(0,w.lW)(e.actorName,to,await e5(n))}catch(e){(0,y.cM)({title:`${e} On Authentication`,message:e,level:y.zq.error})}finally{a(await th(e)())}})},ty=e=>({f_type:"PreAuthzResponse",f_vsn:"1.0.0",proposer:(e||{}).proposer,payer:(e||{}).payer||[],authorization:(e||{}).authorization||[]}),tg=e=>(t,r)=>{let{user:n}=r,a=ty(t),o=[];for(let e of(null!=a.proposer&&o.push(["PROPOSER",a.proposer]),a.payer||[]))o.push(["PAYER",e]);for(let e of a.authorization||[])o.push(["AUTHORIZER",e]);return o.map(t=>{let[r,a]=t;return{tempId:[a.identity.address,a.identity.keyId].join("|"),addr:a.identity.address,keyId:a.identity.keyId,signingFunction:t=>te(e,{service:a,msg:t,platform:e.platform,user:n}),role:{proposer:"PROPOSER"===r,payer:"PAYER"===r,authorizer:"AUTHORIZER"===r}}})},tm=e=>async t=>(tl(e),{...t,tempId:"CURRENT_USER",async resolve(t,r){let n=await tp(e)({redir:!0}),a=e6(n.services,"authz"),o=e6(n.services,"pre-authz");if(o)return tg(e)(await te(e,{service:o,msg:r,platform:e.platform,user:n}),{user:n});if(a)return{...t,tempId:"CURRENT_USER",resolve:null,addr:(0,m.CH)(a.identity.address),keyId:a.identity.keyId,sequenceNum:null,signature:null,signingFunction:async t=>eQ(await te(e,{service:a,msg:t,opts:{includeOlderJsonRpcCall:!0},platform:e.platform,user:n}))};throw Error("No Authz or PreAuthz Service configured for CURRENT_USER")}});function th(e){return function(){return tl(e),(0,w.lW)(e.actorName,ta,null,{expectReply:!0,timeout:0})}}let tv=e=>async()=>{let{addr:t}=await tp(e)();return(0,d.R9)((0,m.dq)(t),d.t.Address)},tw=e=>((0,u.k)(/^[0-9a-f]+$/i.test(e),"Message must be a hex string"),{message:e}),tk=e=>async t=>{tl(e);let r=await tp(e)({redir:!0}),n=e6(r.services,"user-signature");(0,u.k)(n,"Current user must have authorized a signing service.");try{let a=await te(e,{service:n,msg:tw(t),platform:e.platform,user:r});if(Array.isArray(a))return a.map(e=>eQ(e));return[eQ(a)]}catch(e){return e}},tb=e=>{let t={authenticate:tp(e),unauthenticate:function(){tl(e),(0,w.lW)(e.actorName,ti)},authorization:tm(e),signUserMessage:tk(e),subscribe:function(t){tl(e);let r="@EXIT",n=(0,w.Cs)(async n=>{for(n.send(e.actorName,w.kD);;){let a=await n.receive();if(a.tag===r){n.send(e.actorName,w.By);return}t(a.data)}});return()=>(0,w.lW)(n,r)},snapshot:th(e),resolveArgument:tv(e)};return Object.assign(()=>({...t}),{...t})},tE=e=>{let t=M(),r=async()=>e.getStorageProvider?await e.getStorageProvider():await g.vc.first(["fcl.storage","fcl.storage.default"],void 0);return tb({...t,getStorageProvider:r,platform:e.platform,actorName:tr,discovery:e.discovery})};function tC(e){let t=new ex(e.endpoint);if(window?.location?.origin&&t.searchParams.append("l6n",window.location.origin),null!=e.params)for(let[r,n]of Object.entries(e.params||{}))t.searchParams.append(r,n);return t}function tS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.method||"POST",n="GET"===r?void 0:JSON.stringify(t.data||e.data||{});return fetch(tC(e),{method:r,headers:{...e.headers||{},...t.headers||{},"Content-Type":"application/json"},body:n}).then(e=>e.json())}function tP(e){return null==e?null:e.f_vsn?"1.0.0"===e.f_vsn?e:null:{...ee,status:e.status??"APPROVED",reason:e.reason??null,data:e.compositeSignature||e.data||{...e},updates:e1(e.authorizationUpdates),local:e0((e.local||[])[0])}}let tR={"HTTP/GET":"GET","HTTP/POST":"POST"},tA=e=>((0,u.k)(tR[e.method],"Invalid Service Method for type back-channel-rpc",{service:e}),tR[e.method]);async function tN(e){let t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>!0;if((0,u.k)(e,"Missing Polling Service",{service:e}),!r())throw Error("Externally Halted");try{if("undefined"!=typeof document&&"hidden"===document.visibilityState)return await new Promise(e=>setTimeout(e,500)),tN(e,r);t=await tS(e,{method:tA(e)}).then(tP)}catch(e){throw e}switch(t?.status){case"APPROVED":return t.data;case"DECLINED":throw Error(`Declined: ${t.reason||"No reason supplied."}`);default:return await new Promise(e=>setTimeout(e,500)),tN(t?.updates,r)}}let tT=e=>async t=>{let{service:r,body:n,config:a,opts:o}=t,i=await tS(r,{data:{fclVersion:S,service:{params:r.params,data:r.data,type:r.type},config:a,...n}}).then(tP);if(i?.status==="APPROVED")return i.data;if(i?.status==="DECLINED")throw Error(`Declined: ${i.reason||"No reason supplied."}`);if(i?.status==="REDIRECT")return i;if(i?.status==="PENDING"){let t=!0,r=!0,[n,a]=await e(e2(i.local),{serviceEndpoint:tC,onClose:()=>r=!1}),o=()=>{try{a(),r=!1}catch(e){console.error("Frame Close Error",e)}};return tN(i.updates,()=>{let e=t;return t=r,e}).then(e=>(o(),e)).catch(e=>{throw console.error(e),o(),e})}throw console.error("Auto Decline: Invalid Response",{service:r,resp:i}),Error("Auto Decline: Invalid Response")},tI="FCL:VIEW:CLOSE",t_="FCL:VIEW:READY",tO="FCL:VIEW:RESPONSE",tU=e=>"string"==typeof e&&e.toLowerCase(),tL=new Set(["monetizationstart","monetizationpending","monetizationprogress","monetizationstop"]),tD=(e,t)=>console.warn("DEPRECATION NOTICE",`Received ${e}, please use ${t} for this and future versions of FCL`),tx=e=>{let t,{close:r,send:n,onReady:a,onResponse:o,onMessage:i,onCustomRpc:s,getSource:c}=e;return e=>{try{t=c?.()||t}catch(e){t=null}try{if("object"!=typeof e.data||tL.has(e.data.type)||null!=t&&e.source!==t)return;tU(e.data.type)===tU(tI)&&r(),tU(e.data.type)===tU(t_)&&(a(e,{send:n,close:r}),t||=e.source),tU(e.data.type)===tU(tO)&&o(e,{send:n,close:r}),tU(e.data.type)===tU("FCL:VIEW:CUSTOM_RPC")&&s(e.data.payload,{send:n,close:r}),i(e,{send:n,close:r}),tU(e.data.type)===tU("FCL:FRAME:READY")&&(tD(e.data.type,t_),a(e,{send:n,close:r}),t||=e.source),tU(e.data.type)===tU("FCL:FRAME:RESPONSE")&&(tD(e.data.type,tO),o(e,{send:n,close:r})),tU(e.data.type)===tU("FCL:FRAME:CLOSE")&&(tD(e.data.type,tI),r()),tU(e.data.type)===tU("FCL::CHALLENGE::RESPONSE")&&(tD(e.data.type,tO),o(e,{send:n,close:r})),tU(e.data.type)===tU("FCL::AUTHZ_READY")&&(tD(e.data.type,t_),a(e,{send:n,close:r}),t||=e.source),tU(e.data.type)===tU("FCL::CHALLENGE::CANCEL")&&(tD(e.data.type,tI),r()),tU(e.data.type)===tU("FCL::CANCEL")&&(tD(e.data.type,tI),r())}catch(e){console.error("Frame Callback Error",e),r()}}};c||(c=M()),c.config.subscribe(()=>{W(c)({enableRequestLogging:!1}).catch(()=>{})})}}]);